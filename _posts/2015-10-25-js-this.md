---
layout : post
title : JavaScript中this关键字详解
category : web
tagline : "author: ChangSiyuan"
tags : [JavaScript]
---
{% include JB/setup %}

### 引言
- js中，this关键是令人头疼的问题，它的指代对象和this所处的上下文环境、函数调用者等多重因素有关；
- 我们要解决的问题是，this关键字代指哪个对象；
- 本文用丰富的实例让您清晰、明确的判断各种情况下，this关键字所指代的对象；

### 判断原则：
- 原则一：this指的是直接调用函数的那个对象，没有的话就值window；
- 原则二：this代指的对象就是它使用的时候（不是定义的时候）所处的环境的上下文；
- 原则三：当new关键字出现时，this指代new出来的那个对象；
- this是js关键字，某些程序中出现的that仅仅是普通的变量，不是关键字；
- 下面，我们用实例说话，一一验证上述原则；

### 无对象调用函数时this指代window的例子
- 例一：

```
function test(){
			this.x = 1;
			alert(this.x);
		}
test();  //1
alert(x);  //1
```

- 例二：

```
var x = 1;
		function test(){
			alert(this.x);
		}
test();  //1
```

- 例三：

```
var x = 1;
		function test(){
			this.x = 0;
		}
test();  
alert(x); //0
```

- 例四：

```
var x = 0;
		function test(){
			alert(this.x);
		}
var o = {};
o.x = 1;
o.m = test;
o.m.apply();  //0  apply参数为空时，默认调用全局对象，故this指向window
o.m.apply(o);  //1  test函数的调用者是o，故this指代对象o
```

- 例五：
  - 执行第一个this时，function调用者为obj，故this指代obj对象；
  - 执行f函数和匿名函数时，函数没有直接的调用者，故this指代window；

```
var context = "global";
 
var obj = {  
    context: "object",
    method: function () {  
        console.log(this + ":" +this.context);  // [object Object]:object
 
        function f() {
            var context = "function";
            console.log(this + ":" +this.context);   // [object Window]:global
        };
        f(); 
 
        (function(){
            var context = "function";
            console.log(this + ":" +this.context);  // [object Window]:global
        })();
    }
};
 
obj.method();
```

### 有对象调用函数时this指代调用函数者的例子





### 例子一
- 代码：

![this1](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this1.png)

- 说明：
  - ext1.getInfo()中的getInfo()返回的是一个函数：function(){return this.name}；
  - 这个函数已经返回，就和base没有任何关系，现在的代码是：document.write(ext1.function(){return this.name})；
  - 然后，this被使用，this在使用时的上下文环境为ext1，this代指的对象即为ext1，和base无关；
  
### 例子二
- 代码：

![this2](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this2.png)

- 说明：
  - ext1.getInfo()中的getInfo()返回的是一个函数：function(){return this.id+":"+this.name}；
  - 这个函数已经返回，就和base没有任何关系，现在的代码是：ext1.function(){return this.id+":"+this.name}；
  - 然后，this被使用，this在使用时的上下文环境为ext1，this代指的对象即为ext1，和base无关；
  - this.id就是ext.id，this.name就是ext1.name，但是ext1没有name属性，但他的原型是base，根据原型链的知识，应该向上层寻找name属性，直到找到位置；
  - 在base中找到了name属性，故输出"base"；
  
### 例子三
- 代码：

![this3](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this3.png)

- 说明：
  - object.getNameFunc()()通过两层函数返回了this.name，现在的代码是alert(this.name)，和object无关；
  - 此时，this才被使用，显然this指的是window对象，故输出the window；
  - 本例中代码虽然写了这么多，但是完全等价于alert(this.name)，object没有起到任何作用，因为this虽然是在object中定义，但是使用时的上下文环境为window，this代指的对象仅仅和使用环境有关，和在哪里定义毫无关系；
  
### 例子四
- 代码：

![this4](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this4.png)

- 说明：
  - 本例和上例作对比；
  - object.getNameFunc()取得第一层函数时，this对象就被使用，此时上下文环境是object，this就代指object；
  - this赋值给了that，that就代指object；
  - object.getNameFunc()()取得第二层函数时，返回了that.name；
  - 注意，that不是js的关键字，that只是一个普通的变量！
  - 由于that已经被赋值、代指object对象，所以输出My Object；
  
### 例子五
- 代码：

![this5](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this5.png)

- 说明：
  - object.getNameFunc()取得第一层函数，此时this被使用，this所处的上下文环境是object，所以this代指object对象；
  - this赋值给变量that，故that也代指object对象；
  - object.getNameFunc()()取得了第二层函数，返回了this.name+that.name，此时代码变为alert(this.name+that.name)，和object对象没有关系了；
  - 此时，关键字this再次被使用，此时this所处的上下文环境为window，故this代指window，this.name为The window；
  - that不是js关键字，它仅仅是普通的变量，that已经被赋值，代指object，所以that.name为My Object；
  
