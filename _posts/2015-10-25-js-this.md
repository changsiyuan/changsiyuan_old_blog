---
layout : post
title : JavaScript中this关键字详解
category : web
tagline : "author: ChangSiyuan"
tags : [JavaScript]
---
{% include JB/setup %}

### 引言
- js中，this关键是令人头疼的问题，它的指代对象和this所处的上下文环境、函数调用者等多重因素有关；
- 我们要解决的问题是，this关键字代指哪个对象；
- 本文用丰富的实例让您清晰、明确的判断各种情况下，this关键字所指代的对象；

### 判断原则：
- 原则一：this指的是直接调用函数的那个对象，没有的话就值window；
- 原则二：this代指的对象就是它使用的时候（不是定义的时候）所处的环境的上下文；
- 原则三：当new关键字出现时，this指代new出来的那个对象；
- this是js关键字，某些程序中出现的that仅仅是普通的变量，不是关键字；
- 下面，我们用实例说话，一一验证上述原则；

### 无对象调用函数时this指代window的例子
- 例一：

```
function test(){
			this.x = 1;
			alert(this.x);
		}
test();  //1
alert(x);  //1
```

- 例二：

```
var x = 1;
		function test(){
			alert(this.x);
		}
test();  //1
```

- 例三：

```
var x = 1;
		function test(){
			this.x = 0;
		}
test();  
alert(x); //0
```

- 例四：

```
var x = 0;
		function test(){
			alert(this.x);
		}
var o = {};
o.x = 1;
o.m = test;
o.m.apply();  //0  apply参数为空时，默认调用全局对象，故this指向window
o.m.apply(o);  //1  test函数的调用者是o，故this指代对象o
```

- 例五：
  - 执行第一个this时，function调用者为obj，故this指代obj对象；
  - 执行f函数和匿名函数时，函数没有直接的调用者，故this指代window；

```
var context = "global";
 
var obj = {  
    context: "object",
    method: function () {  
        console.log(this + ":" +this.context);  // [object Object]:object
 
        function f() {
            var context = "function";
            console.log(this + ":" +this.context);   // [object Window]:global
        };
        f(); 
 
        (function(){
            var context = "function";
            console.log(this + ":" +this.context);  // [object Window]:global
        })();
    }
};
 
obj.method();
```

### 有对象调用函数时this指代调用函数者的例子
- 例一:
  - o调用了test函数，故this指代对象o

```
function test(){
    alert(this.x);
}
var o = {};
o.x = 1;
o.m = test;
o.m();  //1
```

- 例二：
  - getInfo()函数的调用者是ext1，this指代ext1；

![this1](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this1.png)

- 例三：
  - getInfo()函数的调用者是ext1，this指代ext1；
  - this.id和this.name都是代指ext1对象的id和name，但是由于ext1对象本身没有name属性，所以需要到原型链上查找name属性；

![this2](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this2.png)

- 例四：
  - 内层的funcion中包含了this，但是，内层function没有直接调用者；
  - 故这里的this指window；

![this3](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this3.png)

- 例五：
  - object对象调用了外层函数，所以var that = this中的this指代object对象，执行完此句后，that也指代object对象；
  - that并不是js的关键字，仅仅是一个普通的变量，所以下面return that.name的时候，返回的是object.name；

![this4](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this4.png)

- 例六：
  - object对象直接调用了外层的function，故var that = this中的this指代object对象，执行完此句后，that也指代object对象；
  - 内层function没有直接调用者，故内层函数中的this指代window；

![this5](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this5.png)

- 例七：
  - point对象调用moveTo方法，故this指代point对象；

```
var point = { 
 x : 0, 
 y : 0, 
 moveTo : function(x, y) { 
     this.x = this.x + x; 
     this.y = this.y + y; 
     } 
 };
point.moveTo(1,1); 
console.log(point.x);  //1
console.log(point.y);  //1
console.log(x);  //x is not defined
```

- 例八：
  - moveX和moveY函数没有调用者，所以其中的this指代window，而不是point对象；

```
var point = { 
 x : 0, 
 y : 0, 
 moveTo : function(x, y) { 
     var moveX = function(x) { 
         this.x = x;
     }; 

     var moveY = function(y) { 
        this.y = y;
     }; 
    
     moveX(x); 
     moveY(y); 
    } 
 }; 
 point.moveTo(1,1); 
 point.x; //=>0 
 point.y; //=>0 
 x; //=>1 
 y; //=>1
```

### this指代new出来的那个对象
- 例一：
  - 由于存在new关键字，this指代的对象是new出来的对象，即对象o；

```
function test(){
    this.x = 1;
}
var o = new test();
alert(o.x);  //1
```

- 例二：
  - this指代对象o，而不是window；

```
var x = 2;
function test(){
    this.x = 1;
}
var o = new test();
alert(x);  //2
```

- 例三：
  - np对象是new出来的，所以this指代np对象；
  - p对象不是new出来的，且Point函数无调用者，故this指代window；

```
function Point(x,y){ 
    this.x = x; 
    this.y = y; 
 }
var np=new Point(1,1);
np.x;  //1
var p=Point(2,2);
p.x;  //error, p是一个空对象undefined
window.x;  //2
```

- 例四：
  - apply使得Point函数的调用者为p2，故this指代p2对象；

```
function Point(x, y){ 
    this.x = x; 
    this.y = y; 
    this.moveTo = function(x, y){ 
        this.x = x; 
        this.y = y; 
    } 
 } 
 
var p1 = new Point(0, 0); 
var p2 = {x: 0, y: 0}; 
p1.moveTo.apply(p2, [10, 10]);  //apply实际上为p2.moveTo(10,10)
p2.x;   //10
```

### bind/call/apply重定向this关键字指向





### 例子一
- 代码：

![this1](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this1.png)

- 说明：
  - ext1.getInfo()中的getInfo()返回的是一个函数：function(){return this.name}；
  - 这个函数已经返回，就和base没有任何关系，现在的代码是：document.write(ext1.function(){return this.name})；
  - 然后，this被使用，this在使用时的上下文环境为ext1，this代指的对象即为ext1，和base无关；
  
### 例子二
- 代码：

![this2](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this2.png)

- 说明：
  - ext1.getInfo()中的getInfo()返回的是一个函数：function(){return this.id+":"+this.name}；
  - 这个函数已经返回，就和base没有任何关系，现在的代码是：ext1.function(){return this.id+":"+this.name}；
  - 然后，this被使用，this在使用时的上下文环境为ext1，this代指的对象即为ext1，和base无关；
  - this.id就是ext.id，this.name就是ext1.name，但是ext1没有name属性，但他的原型是base，根据原型链的知识，应该向上层寻找name属性，直到找到位置；
  - 在base中找到了name属性，故输出"base"；
  
### 例子三
- 代码：

![this3](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this3.png)

- 说明：
  - object.getNameFunc()()通过两层函数返回了this.name，现在的代码是alert(this.name)，和object无关；
  - 此时，this才被使用，显然this指的是window对象，故输出the window；
  - 本例中代码虽然写了这么多，但是完全等价于alert(this.name)，object没有起到任何作用，因为this虽然是在object中定义，但是使用时的上下文环境为window，this代指的对象仅仅和使用环境有关，和在哪里定义毫无关系；
  
### 例子四
- 代码：

![this4](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this4.png)

- 说明：
  - 本例和上例作对比；
  - object.getNameFunc()取得第一层函数时，this对象就被使用，此时上下文环境是object，this就代指object；
  - this赋值给了that，that就代指object；
  - object.getNameFunc()()取得第二层函数时，返回了that.name；
  - 注意，that不是js的关键字，that只是一个普通的变量！
  - 由于that已经被赋值、代指object对象，所以输出My Object；
  
### 例子五
- 代码：

![this5](https://raw.githubusercontent.com/changsiyuan/changsiyuan.github.io/master/_image/js-this/this5.png)

- 说明：
  - object.getNameFunc()取得第一层函数，此时this被使用，this所处的上下文环境是object，所以this代指object对象；
  - this赋值给变量that，故that也代指object对象；
  - object.getNameFunc()()取得了第二层函数，返回了this.name+that.name，此时代码变为alert(this.name+that.name)，和object对象没有关系了；
  - 此时，关键字this再次被使用，此时this所处的上下文环境为window，故this代指window，this.name为The window；
  - that不是js关键字，它仅仅是普通的变量，that已经被赋值，代指object，所以that.name为My Object；
  
