---
layout : post
title : JavaScript 闭包详解
category : web
tagline : "author: ChangSiyuan"
tags : [JavaScript]
---
{% include JB/setup %}

### js变量作用域
- 变量的作用域无非就是两种：全局变量和局部变量；
- Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量：

```
var n=999;
　　function f1(){
　　　　alert(n);
　　}
f1(); // 999
```

- 但是，在函数外部自然无法读取函数内的局部变量：

```
function f1(){
　　　　var n=999;
　　}
alert(n); // error
```

- 除非不用var声明：

```
function f1(){
　　　　n=999;
　　}
　　f1();
alert(n); // 999
```

- 总之，js中作用域是链式的，内部可获取外部变量，反之不行；
- 如果函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的，但是反过来就不行，f2内部的局部变量，对f1就是不可见的；
- 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗；
- 这种打破常规，实现在函数外部访问函数私有变量的机制叫做闭包；

### js什么时候进行垃圾回收？
- 在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收；
- 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收；

### 闭包（Closure）的定义
- 闭包就是能够读取其他函数内部变量的函数；
- 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"；
- 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁；

### 闭包的深入理解
看下面程序：

```
function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
}
var result=f1();
result(); // 999
nAdd();
result(); // 1000
```

- result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000，这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除；
- 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中（不满足上面任何一条垃圾回收条件），而f2的存在依赖于f1，因此f1也始终在内存中（不满足上面任何一条垃圾回收条件），不会在调用结束后被垃圾回收机制（garbage collection）回收；
- 这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行；
  - 首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量；
  - 其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作；

### 使用闭包需要注意
- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露,解决方法是，在退出函数之前，将不使用的局部变量全部删除；
- 闭包会在父函数外部，改变父函数内部变量的值，所以如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值；

---

本文参考：[学习Javascript闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)



